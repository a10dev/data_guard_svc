/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "dgiFolderLockTypes_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dgi {

int _kFLockObjectTypeValues[] = {
  FLockObjectType::FLock_Unknown,
  FLockObjectType::FLock_File,
  FLockObjectType::FLock_Directory,
  FLockObjectType::FLock_HardDisk
};
const char* _kFLockObjectTypeNames[] = {
  "FLock_Unknown",
  "FLock_File",
  "FLock_Directory",
  "FLock_HardDisk"
};
const std::map<int, const char*> _FLockObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFLockObjectTypeValues, _kFLockObjectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const FLockObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _FLockObjectType_VALUES_TO_NAMES.find(val);
  if (it != _FLockObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kFLockStateValues[] = {
  FLockState::FLock_UnknownState,
  FLockState::FLock_Missed,
  FLockState::FLock_Locked,
  FLockState::FLock_Unlocked,
  FLockState::FLock_Hidden,
  FLockState::FLock_HiddenAndLocked
};
const char* _kFLockStateNames[] = {
  "FLock_UnknownState",
  "FLock_Missed",
  "FLock_Locked",
  "FLock_Unlocked",
  "FLock_Hidden",
  "FLock_HiddenAndLocked"
};
const std::map<int, const char*> _FLockState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kFLockStateValues, _kFLockStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const FLockState::type& val) {
  std::map<int, const char*>::const_iterator it = _FLockState_VALUES_TO_NAMES.find(val);
  if (it != _FLockState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


FLockObject::~FLockObject() throw() {
}


void FLockObject::__set_type(const FLockObjectType::type val) {
  this->type = val;
}

void FLockObject::__set_flockId(const std::string& val) {
  this->flockId = val;
}

void FLockObject::__set_path(const std::string& val) {
  this->path = val;
}
std::ostream& operator<<(std::ostream& out, const FLockObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FLockObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (FLockObjectType::type)ecast0;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->flockId);
          this->__isset.flockId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FLockObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FLockObject");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flockId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->flockId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FLockObject &a, FLockObject &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.flockId, b.flockId);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

FLockObject::FLockObject(const FLockObject& other1) {
  type = other1.type;
  flockId = other1.flockId;
  path = other1.path;
  __isset = other1.__isset;
}
FLockObject& FLockObject::operator=(const FLockObject& other2) {
  type = other2.type;
  flockId = other2.flockId;
  path = other2.path;
  __isset = other2.__isset;
  return *this;
}
void FLockObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FLockObject(";
  out << "type=" << to_string(type);
  out << ", " << "flockId=" << to_string(flockId);
  out << ", " << "path=" << to_string(path);
  out << ")";
}


FLockObjectError::~FLockObjectError() throw() {
}


void FLockObjectError::__set_erObject(const FLockObject& val) {
  this->erObject = val;
}

void FLockObjectError::__set_status(const  ::dgi::DgiStatus::type val) {
  this->status = val;
}

void FLockObjectError::__set_description(const std::string& val) {
  this->description = val;
}
std::ostream& operator<<(std::ostream& out, const FLockObjectError& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FLockObjectError::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->erObject.read(iprot);
          this->__isset.erObject = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->status = ( ::dgi::DgiStatus::type)ecast3;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FLockObjectError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FLockObjectError");

  xfer += oprot->writeFieldBegin("erObject", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->erObject.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FLockObjectError &a, FLockObjectError &b) {
  using ::std::swap;
  swap(a.erObject, b.erObject);
  swap(a.status, b.status);
  swap(a.description, b.description);
  swap(a.__isset, b.__isset);
}

FLockObjectError::FLockObjectError(const FLockObjectError& other4) {
  erObject = other4.erObject;
  status = other4.status;
  description = other4.description;
  __isset = other4.__isset;
}
FLockObjectError& FLockObjectError::operator=(const FLockObjectError& other5) {
  erObject = other5.erObject;
  status = other5.status;
  description = other5.description;
  __isset = other5.__isset;
  return *this;
}
void FLockObjectError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FLockObjectError(";
  out << "erObject=" << to_string(erObject);
  out << ", " << "status=" << to_string(status);
  out << ", " << "description=" << to_string(description);
  out << ")";
}


FLockInfo::~FLockInfo() throw() {
}


void FLockInfo::__set_obj(const FLockObject& val) {
  this->obj = val;
}

void FLockInfo::__set_state(const FLockState::type val) {
  this->state = val;
}
std::ostream& operator<<(std::ostream& out, const FLockInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FLockInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->obj.read(iprot);
          this->__isset.obj = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->state = (FLockState::type)ecast6;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FLockInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FLockInfo");

  xfer += oprot->writeFieldBegin("obj", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->obj.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FLockInfo &a, FLockInfo &b) {
  using ::std::swap;
  swap(a.obj, b.obj);
  swap(a.state, b.state);
  swap(a.__isset, b.__isset);
}

FLockInfo::FLockInfo(const FLockInfo& other7) {
  obj = other7.obj;
  state = other7.state;
  __isset = other7.__isset;
}
FLockInfo& FLockInfo::operator=(const FLockInfo& other8) {
  obj = other8.obj;
  state = other8.state;
  __isset = other8.__isset;
  return *this;
}
void FLockInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FLockInfo(";
  out << "obj=" << to_string(obj);
  out << ", " << "state=" << to_string(state);
  out << ")";
}


FLockStateResponse::~FLockStateResponse() throw() {
}


void FLockStateResponse::__set_result(const  ::dgi::DgiResult& val) {
  this->result = val;
}

void FLockStateResponse::__set_flinf(const FLockInfo& val) {
  this->flinf = val;
}
std::ostream& operator<<(std::ostream& out, const FLockStateResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FLockStateResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flinf.read(iprot);
          this->__isset.flinf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FLockStateResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FLockStateResponse");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flinf", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->flinf.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FLockStateResponse &a, FLockStateResponse &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.flinf, b.flinf);
  swap(a.__isset, b.__isset);
}

FLockStateResponse::FLockStateResponse(const FLockStateResponse& other9) {
  result = other9.result;
  flinf = other9.flinf;
  __isset = other9.__isset;
}
FLockStateResponse& FLockStateResponse::operator=(const FLockStateResponse& other10) {
  result = other10.result;
  flinf = other10.flinf;
  __isset = other10.__isset;
  return *this;
}
void FLockStateResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FLockStateResponse(";
  out << "result=" << to_string(result);
  out << ", " << "flinf=" << to_string(flinf);
  out << ")";
}


FLockListResponse::~FLockListResponse() throw() {
}


void FLockListResponse::__set_result(const  ::dgi::DgiResult& val) {
  this->result = val;
}

void FLockListResponse::__set_flocks(const FLockInfoList& val) {
  this->flocks = val;
}
std::ostream& operator<<(std::ostream& out, const FLockListResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FLockListResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->flocks.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->flocks.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += this->flocks[_i15].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.flocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FLockListResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FLockListResponse");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flocks", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->flocks.size()));
    std::vector<FLockInfo> ::const_iterator _iter16;
    for (_iter16 = this->flocks.begin(); _iter16 != this->flocks.end(); ++_iter16)
    {
      xfer += (*_iter16).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FLockListResponse &a, FLockListResponse &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.flocks, b.flocks);
  swap(a.__isset, b.__isset);
}

FLockListResponse::FLockListResponse(const FLockListResponse& other17) {
  result = other17.result;
  flocks = other17.flocks;
  __isset = other17.__isset;
}
FLockListResponse& FLockListResponse::operator=(const FLockListResponse& other18) {
  result = other18.result;
  flocks = other18.flocks;
  __isset = other18.__isset;
  return *this;
}
void FLockListResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FLockListResponse(";
  out << "result=" << to_string(result);
  out << ", " << "flocks=" << to_string(flocks);
  out << ")";
}


FLockCacheInfo::~FLockCacheInfo() throw() {
}


void FLockCacheInfo::__set_totalEntries(const int32_t val) {
  this->totalEntries = val;
}

void FLockCacheInfo::__set_freeEntries(const int32_t val) {
  this->freeEntries = val;
}

void FLockCacheInfo::__set_maxCollisionLength(const int32_t val) {
  this->maxCollisionLength = val;
}
std::ostream& operator<<(std::ostream& out, const FLockCacheInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FLockCacheInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalEntries);
          this->__isset.totalEntries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->freeEntries);
          this->__isset.freeEntries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCollisionLength);
          this->__isset.maxCollisionLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FLockCacheInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FLockCacheInfo");

  xfer += oprot->writeFieldBegin("totalEntries", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->totalEntries);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeEntries", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->freeEntries);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCollisionLength", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->maxCollisionLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FLockCacheInfo &a, FLockCacheInfo &b) {
  using ::std::swap;
  swap(a.totalEntries, b.totalEntries);
  swap(a.freeEntries, b.freeEntries);
  swap(a.maxCollisionLength, b.maxCollisionLength);
  swap(a.__isset, b.__isset);
}

FLockCacheInfo::FLockCacheInfo(const FLockCacheInfo& other19) {
  totalEntries = other19.totalEntries;
  freeEntries = other19.freeEntries;
  maxCollisionLength = other19.maxCollisionLength;
  __isset = other19.__isset;
}
FLockCacheInfo& FLockCacheInfo::operator=(const FLockCacheInfo& other20) {
  totalEntries = other20.totalEntries;
  freeEntries = other20.freeEntries;
  maxCollisionLength = other20.maxCollisionLength;
  __isset = other20.__isset;
  return *this;
}
void FLockCacheInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FLockCacheInfo(";
  out << "totalEntries=" << to_string(totalEntries);
  out << ", " << "freeEntries=" << to_string(freeEntries);
  out << ", " << "maxCollisionLength=" << to_string(maxCollisionLength);
  out << ")";
}

} // namespace
