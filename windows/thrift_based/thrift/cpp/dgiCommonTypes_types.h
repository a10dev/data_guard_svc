/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef dgiCommonTypes_TYPES_H
#define dgiCommonTypes_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace dgi {

struct DgiStatus {
  enum type {
    Success = 0,
    UnknownError = 1,
    NotFound = 2,
    CriticalError = 3,
    AccessDenied = 4,
    InvalidFormat = 5,
    InProcess = 6,
    Completed = 7,
    LimitAchieved = 8,
    PresentAlready = 9,
    DriverNotConnected = 10,
    UnknownType = 11,
    HaveNoResponse = 12,
    NoMasterPassword = 13,
    LicenseExpired = 14,
    LicenseExpireSoon = 15,
    NotEncoded = 16,
    EncodedAlready = 17,
    WrongEncryptionKey = 18,
    DecodedButIntegrityCompromised = 19,
    TypeConvertionError = 20,
    NotLoaded = 21,
    FLockWasNotSigned = 22
  };
};

extern const std::map<int, const char*> _DgiStatus_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const DgiStatus::type& val);

typedef std::string DgiSid;

typedef int32_t AsyncId;

typedef std::string utf8string;

class DgiResult;

class AsyncResponse;

class BoolResponse;

class AuthResponse;

class SubSystemStateResponse;

typedef struct _DgiResult__isset {
  _DgiResult__isset() : status(false), description(false) {}
  bool status :1;
  bool description :1;
} _DgiResult__isset;

class DgiResult : public virtual ::apache::thrift::TBase {
 public:

  DgiResult(const DgiResult&);
  DgiResult& operator=(const DgiResult&);
  DgiResult() : status((DgiStatus::type)0), description() {
  }

  virtual ~DgiResult() throw();
  DgiStatus::type status;
  std::string description;

  _DgiResult__isset __isset;

  void __set_status(const DgiStatus::type val);

  void __set_description(const std::string& val);

  bool operator == (const DgiResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(description == rhs.description))
      return false;
    return true;
  }
  bool operator != (const DgiResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DgiResult &a, DgiResult &b);

std::ostream& operator<<(std::ostream& out, const DgiResult& obj);

typedef struct _AsyncResponse__isset {
  _AsyncResponse__isset() : result(false), asyncId(false) {}
  bool result :1;
  bool asyncId :1;
} _AsyncResponse__isset;

class AsyncResponse : public virtual ::apache::thrift::TBase {
 public:

  AsyncResponse(const AsyncResponse&);
  AsyncResponse& operator=(const AsyncResponse&);
  AsyncResponse() : asyncId(0) {
  }

  virtual ~AsyncResponse() throw();
  DgiResult result;
  AsyncId asyncId;

  _AsyncResponse__isset __isset;

  void __set_result(const DgiResult& val);

  void __set_asyncId(const AsyncId val);

  bool operator == (const AsyncResponse & rhs) const
  {
    if (!(result == rhs.result))
      return false;
    if (!(asyncId == rhs.asyncId))
      return false;
    return true;
  }
  bool operator != (const AsyncResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AsyncResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AsyncResponse &a, AsyncResponse &b);

std::ostream& operator<<(std::ostream& out, const AsyncResponse& obj);

typedef struct _BoolResponse__isset {
  _BoolResponse__isset() : errorResult(false), bool_result(false) {}
  bool errorResult :1;
  bool bool_result :1;
} _BoolResponse__isset;

class BoolResponse : public virtual ::apache::thrift::TBase {
 public:

  BoolResponse(const BoolResponse&);
  BoolResponse& operator=(const BoolResponse&);
  BoolResponse() : bool_result(0) {
  }

  virtual ~BoolResponse() throw();
  DgiResult errorResult;
  bool bool_result;

  _BoolResponse__isset __isset;

  void __set_errorResult(const DgiResult& val);

  void __set_bool_result(const bool val);

  bool operator == (const BoolResponse & rhs) const
  {
    if (!(errorResult == rhs.errorResult))
      return false;
    if (!(bool_result == rhs.bool_result))
      return false;
    return true;
  }
  bool operator != (const BoolResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BoolResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BoolResponse &a, BoolResponse &b);

std::ostream& operator<<(std::ostream& out, const BoolResponse& obj);

typedef struct _AuthResponse__isset {
  _AuthResponse__isset() : result(false), sessionId(false) {}
  bool result :1;
  bool sessionId :1;
} _AuthResponse__isset;

class AuthResponse : public virtual ::apache::thrift::TBase {
 public:

  AuthResponse(const AuthResponse&);
  AuthResponse& operator=(const AuthResponse&);
  AuthResponse() : sessionId() {
  }

  virtual ~AuthResponse() throw();
  DgiResult result;
  DgiSid sessionId;

  _AuthResponse__isset __isset;

  void __set_result(const DgiResult& val);

  void __set_sessionId(const DgiSid& val);

  bool operator == (const AuthResponse & rhs) const
  {
    if (!(result == rhs.result))
      return false;
    if (!(sessionId == rhs.sessionId))
      return false;
    return true;
  }
  bool operator != (const AuthResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuthResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AuthResponse &a, AuthResponse &b);

std::ostream& operator<<(std::ostream& out, const AuthResponse& obj);

typedef struct _SubSystemStateResponse__isset {
  _SubSystemStateResponse__isset() : result(false), hasProblems(false), report(false) {}
  bool result :1;
  bool hasProblems :1;
  bool report :1;
} _SubSystemStateResponse__isset;

class SubSystemStateResponse : public virtual ::apache::thrift::TBase {
 public:

  SubSystemStateResponse(const SubSystemStateResponse&);
  SubSystemStateResponse& operator=(const SubSystemStateResponse&);
  SubSystemStateResponse() : hasProblems(0) {
  }

  virtual ~SubSystemStateResponse() throw();
  DgiResult result;
  bool hasProblems;
  std::vector<DgiResult>  report;

  _SubSystemStateResponse__isset __isset;

  void __set_result(const DgiResult& val);

  void __set_hasProblems(const bool val);

  void __set_report(const std::vector<DgiResult> & val);

  bool operator == (const SubSystemStateResponse & rhs) const
  {
    if (!(result == rhs.result))
      return false;
    if (!(hasProblems == rhs.hasProblems))
      return false;
    if (!(report == rhs.report))
      return false;
    return true;
  }
  bool operator != (const SubSystemStateResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SubSystemStateResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SubSystemStateResponse &a, SubSystemStateResponse &b);

std::ostream& operator<<(std::ostream& out, const SubSystemStateResponse& obj);

} // namespace

#endif
