/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef DgiFolderLock_H
#define DgiFolderLock_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "dgiFolderLock_types.h"

namespace dgi {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class DgiFolderLockIf {
 public:
  virtual ~DgiFolderLockIf() {}
  virtual void getSubsState( ::dgi::SubSystemStateResponse& _return) = 0;
  virtual void isSupportedFs( ::dgi::BoolResponse& _return, const std::string& _path) = 0;
  virtual  ::dgi::DgiStatus::type add(const  ::dgi::DgiSid& _sid, const  ::dgi::FLockInfo& _flock) = 0;
  virtual void getFlocks( ::dgi::FLockListResponse& _return, const  ::dgi::DgiSid& _sid) = 0;
  virtual void getState( ::dgi::FLockStateResponse& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath) = 0;
  virtual void setState( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath, const  ::dgi::FLockState::type _newState) = 0;
  virtual void present( ::dgi::BoolResponse& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath) = 0;
  virtual void presentById( ::dgi::BoolResponse& _return, const  ::dgi::DgiSid& _sid, const std::string& _flockId) = 0;
  virtual void remove( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath) = 0;
  virtual void removeAll( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid) = 0;
  virtual void getCacheInfo( ::dgi::FLockCacheInfo& _return) = 0;
};

class DgiFolderLockIfFactory {
 public:
  typedef DgiFolderLockIf Handler;

  virtual ~DgiFolderLockIfFactory() {}

  virtual DgiFolderLockIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(DgiFolderLockIf* /* handler */) = 0;
};

class DgiFolderLockIfSingletonFactory : virtual public DgiFolderLockIfFactory {
 public:
  DgiFolderLockIfSingletonFactory(const ::apache::thrift::stdcxx::shared_ptr<DgiFolderLockIf>& iface) : iface_(iface) {}
  virtual ~DgiFolderLockIfSingletonFactory() {}

  virtual DgiFolderLockIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(DgiFolderLockIf* /* handler */) {}

 protected:
  ::apache::thrift::stdcxx::shared_ptr<DgiFolderLockIf> iface_;
};

class DgiFolderLockNull : virtual public DgiFolderLockIf {
 public:
  virtual ~DgiFolderLockNull() {}
  void getSubsState( ::dgi::SubSystemStateResponse& /* _return */) {
    return;
  }
  void isSupportedFs( ::dgi::BoolResponse& /* _return */, const std::string& /* _path */) {
    return;
  }
   ::dgi::DgiStatus::type add(const  ::dgi::DgiSid& /* _sid */, const  ::dgi::FLockInfo& /* _flock */) {
     ::dgi::DgiStatus::type _return = ( ::dgi::DgiStatus::type)0;
    return _return;
  }
  void getFlocks( ::dgi::FLockListResponse& /* _return */, const  ::dgi::DgiSid& /* _sid */) {
    return;
  }
  void getState( ::dgi::FLockStateResponse& /* _return */, const  ::dgi::DgiSid& /* _sid */, const  ::dgi::utf8string& /* _flockPath */) {
    return;
  }
  void setState( ::dgi::DgiResult& /* _return */, const  ::dgi::DgiSid& /* _sid */, const  ::dgi::utf8string& /* _flockPath */, const  ::dgi::FLockState::type /* _newState */) {
    return;
  }
  void present( ::dgi::BoolResponse& /* _return */, const  ::dgi::DgiSid& /* _sid */, const  ::dgi::utf8string& /* _flockPath */) {
    return;
  }
  void presentById( ::dgi::BoolResponse& /* _return */, const  ::dgi::DgiSid& /* _sid */, const std::string& /* _flockId */) {
    return;
  }
  void remove( ::dgi::DgiResult& /* _return */, const  ::dgi::DgiSid& /* _sid */, const  ::dgi::utf8string& /* _flockPath */) {
    return;
  }
  void removeAll( ::dgi::DgiResult& /* _return */, const  ::dgi::DgiSid& /* _sid */) {
    return;
  }
  void getCacheInfo( ::dgi::FLockCacheInfo& /* _return */) {
    return;
  }
};


class DgiFolderLock_getSubsState_args {
 public:

  DgiFolderLock_getSubsState_args(const DgiFolderLock_getSubsState_args&);
  DgiFolderLock_getSubsState_args& operator=(const DgiFolderLock_getSubsState_args&);
  DgiFolderLock_getSubsState_args() {
  }

  virtual ~DgiFolderLock_getSubsState_args() throw();

  bool operator == (const DgiFolderLock_getSubsState_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DgiFolderLock_getSubsState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_getSubsState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DgiFolderLock_getSubsState_pargs {
 public:


  virtual ~DgiFolderLock_getSubsState_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_getSubsState_result__isset {
  _DgiFolderLock_getSubsState_result__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_getSubsState_result__isset;

class DgiFolderLock_getSubsState_result {
 public:

  DgiFolderLock_getSubsState_result(const DgiFolderLock_getSubsState_result&);
  DgiFolderLock_getSubsState_result& operator=(const DgiFolderLock_getSubsState_result&);
  DgiFolderLock_getSubsState_result() {
  }

  virtual ~DgiFolderLock_getSubsState_result() throw();
   ::dgi::SubSystemStateResponse success;

  _DgiFolderLock_getSubsState_result__isset __isset;

  void __set_success(const  ::dgi::SubSystemStateResponse& val);

  bool operator == (const DgiFolderLock_getSubsState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_getSubsState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_getSubsState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_getSubsState_presult__isset {
  _DgiFolderLock_getSubsState_presult__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_getSubsState_presult__isset;

class DgiFolderLock_getSubsState_presult {
 public:


  virtual ~DgiFolderLock_getSubsState_presult() throw();
   ::dgi::SubSystemStateResponse* success;

  _DgiFolderLock_getSubsState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DgiFolderLock_isSupportedFs_args__isset {
  _DgiFolderLock_isSupportedFs_args__isset() : _path(false) {}
  bool _path :1;
} _DgiFolderLock_isSupportedFs_args__isset;

class DgiFolderLock_isSupportedFs_args {
 public:

  DgiFolderLock_isSupportedFs_args(const DgiFolderLock_isSupportedFs_args&);
  DgiFolderLock_isSupportedFs_args& operator=(const DgiFolderLock_isSupportedFs_args&);
  DgiFolderLock_isSupportedFs_args() : _path() {
  }

  virtual ~DgiFolderLock_isSupportedFs_args() throw();
  std::string _path;

  _DgiFolderLock_isSupportedFs_args__isset __isset;

  void __set__path(const std::string& val);

  bool operator == (const DgiFolderLock_isSupportedFs_args & rhs) const
  {
    if (!(_path == rhs._path))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_isSupportedFs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_isSupportedFs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DgiFolderLock_isSupportedFs_pargs {
 public:


  virtual ~DgiFolderLock_isSupportedFs_pargs() throw();
  const std::string* _path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_isSupportedFs_result__isset {
  _DgiFolderLock_isSupportedFs_result__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_isSupportedFs_result__isset;

class DgiFolderLock_isSupportedFs_result {
 public:

  DgiFolderLock_isSupportedFs_result(const DgiFolderLock_isSupportedFs_result&);
  DgiFolderLock_isSupportedFs_result& operator=(const DgiFolderLock_isSupportedFs_result&);
  DgiFolderLock_isSupportedFs_result() {
  }

  virtual ~DgiFolderLock_isSupportedFs_result() throw();
   ::dgi::BoolResponse success;

  _DgiFolderLock_isSupportedFs_result__isset __isset;

  void __set_success(const  ::dgi::BoolResponse& val);

  bool operator == (const DgiFolderLock_isSupportedFs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_isSupportedFs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_isSupportedFs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_isSupportedFs_presult__isset {
  _DgiFolderLock_isSupportedFs_presult__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_isSupportedFs_presult__isset;

class DgiFolderLock_isSupportedFs_presult {
 public:


  virtual ~DgiFolderLock_isSupportedFs_presult() throw();
   ::dgi::BoolResponse* success;

  _DgiFolderLock_isSupportedFs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DgiFolderLock_add_args__isset {
  _DgiFolderLock_add_args__isset() : _sid(false), _flock(false) {}
  bool _sid :1;
  bool _flock :1;
} _DgiFolderLock_add_args__isset;

class DgiFolderLock_add_args {
 public:

  DgiFolderLock_add_args(const DgiFolderLock_add_args&);
  DgiFolderLock_add_args& operator=(const DgiFolderLock_add_args&);
  DgiFolderLock_add_args() : _sid() {
  }

  virtual ~DgiFolderLock_add_args() throw();
   ::dgi::DgiSid _sid;
   ::dgi::FLockInfo _flock;

  _DgiFolderLock_add_args__isset __isset;

  void __set__sid(const  ::dgi::DgiSid& val);

  void __set__flock(const  ::dgi::FLockInfo& val);

  bool operator == (const DgiFolderLock_add_args & rhs) const
  {
    if (!(_sid == rhs._sid))
      return false;
    if (!(_flock == rhs._flock))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_add_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_add_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DgiFolderLock_add_pargs {
 public:


  virtual ~DgiFolderLock_add_pargs() throw();
  const  ::dgi::DgiSid* _sid;
  const  ::dgi::FLockInfo* _flock;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_add_result__isset {
  _DgiFolderLock_add_result__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_add_result__isset;

class DgiFolderLock_add_result {
 public:

  DgiFolderLock_add_result(const DgiFolderLock_add_result&);
  DgiFolderLock_add_result& operator=(const DgiFolderLock_add_result&);
  DgiFolderLock_add_result() : success(( ::dgi::DgiStatus::type)0) {
  }

  virtual ~DgiFolderLock_add_result() throw();
   ::dgi::DgiStatus::type success;

  _DgiFolderLock_add_result__isset __isset;

  void __set_success(const  ::dgi::DgiStatus::type val);

  bool operator == (const DgiFolderLock_add_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_add_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_add_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_add_presult__isset {
  _DgiFolderLock_add_presult__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_add_presult__isset;

class DgiFolderLock_add_presult {
 public:


  virtual ~DgiFolderLock_add_presult() throw();
   ::dgi::DgiStatus::type* success;

  _DgiFolderLock_add_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DgiFolderLock_getFlocks_args__isset {
  _DgiFolderLock_getFlocks_args__isset() : _sid(false) {}
  bool _sid :1;
} _DgiFolderLock_getFlocks_args__isset;

class DgiFolderLock_getFlocks_args {
 public:

  DgiFolderLock_getFlocks_args(const DgiFolderLock_getFlocks_args&);
  DgiFolderLock_getFlocks_args& operator=(const DgiFolderLock_getFlocks_args&);
  DgiFolderLock_getFlocks_args() : _sid() {
  }

  virtual ~DgiFolderLock_getFlocks_args() throw();
   ::dgi::DgiSid _sid;

  _DgiFolderLock_getFlocks_args__isset __isset;

  void __set__sid(const  ::dgi::DgiSid& val);

  bool operator == (const DgiFolderLock_getFlocks_args & rhs) const
  {
    if (!(_sid == rhs._sid))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_getFlocks_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_getFlocks_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DgiFolderLock_getFlocks_pargs {
 public:


  virtual ~DgiFolderLock_getFlocks_pargs() throw();
  const  ::dgi::DgiSid* _sid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_getFlocks_result__isset {
  _DgiFolderLock_getFlocks_result__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_getFlocks_result__isset;

class DgiFolderLock_getFlocks_result {
 public:

  DgiFolderLock_getFlocks_result(const DgiFolderLock_getFlocks_result&);
  DgiFolderLock_getFlocks_result& operator=(const DgiFolderLock_getFlocks_result&);
  DgiFolderLock_getFlocks_result() {
  }

  virtual ~DgiFolderLock_getFlocks_result() throw();
   ::dgi::FLockListResponse success;

  _DgiFolderLock_getFlocks_result__isset __isset;

  void __set_success(const  ::dgi::FLockListResponse& val);

  bool operator == (const DgiFolderLock_getFlocks_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_getFlocks_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_getFlocks_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_getFlocks_presult__isset {
  _DgiFolderLock_getFlocks_presult__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_getFlocks_presult__isset;

class DgiFolderLock_getFlocks_presult {
 public:


  virtual ~DgiFolderLock_getFlocks_presult() throw();
   ::dgi::FLockListResponse* success;

  _DgiFolderLock_getFlocks_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DgiFolderLock_getState_args__isset {
  _DgiFolderLock_getState_args__isset() : _sid(false), _flockPath(false) {}
  bool _sid :1;
  bool _flockPath :1;
} _DgiFolderLock_getState_args__isset;

class DgiFolderLock_getState_args {
 public:

  DgiFolderLock_getState_args(const DgiFolderLock_getState_args&);
  DgiFolderLock_getState_args& operator=(const DgiFolderLock_getState_args&);
  DgiFolderLock_getState_args() : _sid(), _flockPath() {
  }

  virtual ~DgiFolderLock_getState_args() throw();
   ::dgi::DgiSid _sid;
   ::dgi::utf8string _flockPath;

  _DgiFolderLock_getState_args__isset __isset;

  void __set__sid(const  ::dgi::DgiSid& val);

  void __set__flockPath(const  ::dgi::utf8string& val);

  bool operator == (const DgiFolderLock_getState_args & rhs) const
  {
    if (!(_sid == rhs._sid))
      return false;
    if (!(_flockPath == rhs._flockPath))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_getState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_getState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DgiFolderLock_getState_pargs {
 public:


  virtual ~DgiFolderLock_getState_pargs() throw();
  const  ::dgi::DgiSid* _sid;
  const  ::dgi::utf8string* _flockPath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_getState_result__isset {
  _DgiFolderLock_getState_result__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_getState_result__isset;

class DgiFolderLock_getState_result {
 public:

  DgiFolderLock_getState_result(const DgiFolderLock_getState_result&);
  DgiFolderLock_getState_result& operator=(const DgiFolderLock_getState_result&);
  DgiFolderLock_getState_result() {
  }

  virtual ~DgiFolderLock_getState_result() throw();
   ::dgi::FLockStateResponse success;

  _DgiFolderLock_getState_result__isset __isset;

  void __set_success(const  ::dgi::FLockStateResponse& val);

  bool operator == (const DgiFolderLock_getState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_getState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_getState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_getState_presult__isset {
  _DgiFolderLock_getState_presult__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_getState_presult__isset;

class DgiFolderLock_getState_presult {
 public:


  virtual ~DgiFolderLock_getState_presult() throw();
   ::dgi::FLockStateResponse* success;

  _DgiFolderLock_getState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DgiFolderLock_setState_args__isset {
  _DgiFolderLock_setState_args__isset() : _sid(false), _flockPath(false), _newState(false) {}
  bool _sid :1;
  bool _flockPath :1;
  bool _newState :1;
} _DgiFolderLock_setState_args__isset;

class DgiFolderLock_setState_args {
 public:

  DgiFolderLock_setState_args(const DgiFolderLock_setState_args&);
  DgiFolderLock_setState_args& operator=(const DgiFolderLock_setState_args&);
  DgiFolderLock_setState_args() : _sid(), _flockPath(), _newState(( ::dgi::FLockState::type)0) {
  }

  virtual ~DgiFolderLock_setState_args() throw();
   ::dgi::DgiSid _sid;
   ::dgi::utf8string _flockPath;
   ::dgi::FLockState::type _newState;

  _DgiFolderLock_setState_args__isset __isset;

  void __set__sid(const  ::dgi::DgiSid& val);

  void __set__flockPath(const  ::dgi::utf8string& val);

  void __set__newState(const  ::dgi::FLockState::type val);

  bool operator == (const DgiFolderLock_setState_args & rhs) const
  {
    if (!(_sid == rhs._sid))
      return false;
    if (!(_flockPath == rhs._flockPath))
      return false;
    if (!(_newState == rhs._newState))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_setState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_setState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DgiFolderLock_setState_pargs {
 public:


  virtual ~DgiFolderLock_setState_pargs() throw();
  const  ::dgi::DgiSid* _sid;
  const  ::dgi::utf8string* _flockPath;
  const  ::dgi::FLockState::type* _newState;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_setState_result__isset {
  _DgiFolderLock_setState_result__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_setState_result__isset;

class DgiFolderLock_setState_result {
 public:

  DgiFolderLock_setState_result(const DgiFolderLock_setState_result&);
  DgiFolderLock_setState_result& operator=(const DgiFolderLock_setState_result&);
  DgiFolderLock_setState_result() {
  }

  virtual ~DgiFolderLock_setState_result() throw();
   ::dgi::DgiResult success;

  _DgiFolderLock_setState_result__isset __isset;

  void __set_success(const  ::dgi::DgiResult& val);

  bool operator == (const DgiFolderLock_setState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_setState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_setState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_setState_presult__isset {
  _DgiFolderLock_setState_presult__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_setState_presult__isset;

class DgiFolderLock_setState_presult {
 public:


  virtual ~DgiFolderLock_setState_presult() throw();
   ::dgi::DgiResult* success;

  _DgiFolderLock_setState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DgiFolderLock_present_args__isset {
  _DgiFolderLock_present_args__isset() : _sid(false), _flockPath(false) {}
  bool _sid :1;
  bool _flockPath :1;
} _DgiFolderLock_present_args__isset;

class DgiFolderLock_present_args {
 public:

  DgiFolderLock_present_args(const DgiFolderLock_present_args&);
  DgiFolderLock_present_args& operator=(const DgiFolderLock_present_args&);
  DgiFolderLock_present_args() : _sid(), _flockPath() {
  }

  virtual ~DgiFolderLock_present_args() throw();
   ::dgi::DgiSid _sid;
   ::dgi::utf8string _flockPath;

  _DgiFolderLock_present_args__isset __isset;

  void __set__sid(const  ::dgi::DgiSid& val);

  void __set__flockPath(const  ::dgi::utf8string& val);

  bool operator == (const DgiFolderLock_present_args & rhs) const
  {
    if (!(_sid == rhs._sid))
      return false;
    if (!(_flockPath == rhs._flockPath))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_present_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_present_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DgiFolderLock_present_pargs {
 public:


  virtual ~DgiFolderLock_present_pargs() throw();
  const  ::dgi::DgiSid* _sid;
  const  ::dgi::utf8string* _flockPath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_present_result__isset {
  _DgiFolderLock_present_result__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_present_result__isset;

class DgiFolderLock_present_result {
 public:

  DgiFolderLock_present_result(const DgiFolderLock_present_result&);
  DgiFolderLock_present_result& operator=(const DgiFolderLock_present_result&);
  DgiFolderLock_present_result() {
  }

  virtual ~DgiFolderLock_present_result() throw();
   ::dgi::BoolResponse success;

  _DgiFolderLock_present_result__isset __isset;

  void __set_success(const  ::dgi::BoolResponse& val);

  bool operator == (const DgiFolderLock_present_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_present_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_present_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_present_presult__isset {
  _DgiFolderLock_present_presult__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_present_presult__isset;

class DgiFolderLock_present_presult {
 public:


  virtual ~DgiFolderLock_present_presult() throw();
   ::dgi::BoolResponse* success;

  _DgiFolderLock_present_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DgiFolderLock_presentById_args__isset {
  _DgiFolderLock_presentById_args__isset() : _sid(false), _flockId(false) {}
  bool _sid :1;
  bool _flockId :1;
} _DgiFolderLock_presentById_args__isset;

class DgiFolderLock_presentById_args {
 public:

  DgiFolderLock_presentById_args(const DgiFolderLock_presentById_args&);
  DgiFolderLock_presentById_args& operator=(const DgiFolderLock_presentById_args&);
  DgiFolderLock_presentById_args() : _sid(), _flockId() {
  }

  virtual ~DgiFolderLock_presentById_args() throw();
   ::dgi::DgiSid _sid;
  std::string _flockId;

  _DgiFolderLock_presentById_args__isset __isset;

  void __set__sid(const  ::dgi::DgiSid& val);

  void __set__flockId(const std::string& val);

  bool operator == (const DgiFolderLock_presentById_args & rhs) const
  {
    if (!(_sid == rhs._sid))
      return false;
    if (!(_flockId == rhs._flockId))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_presentById_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_presentById_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DgiFolderLock_presentById_pargs {
 public:


  virtual ~DgiFolderLock_presentById_pargs() throw();
  const  ::dgi::DgiSid* _sid;
  const std::string* _flockId;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_presentById_result__isset {
  _DgiFolderLock_presentById_result__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_presentById_result__isset;

class DgiFolderLock_presentById_result {
 public:

  DgiFolderLock_presentById_result(const DgiFolderLock_presentById_result&);
  DgiFolderLock_presentById_result& operator=(const DgiFolderLock_presentById_result&);
  DgiFolderLock_presentById_result() {
  }

  virtual ~DgiFolderLock_presentById_result() throw();
   ::dgi::BoolResponse success;

  _DgiFolderLock_presentById_result__isset __isset;

  void __set_success(const  ::dgi::BoolResponse& val);

  bool operator == (const DgiFolderLock_presentById_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_presentById_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_presentById_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_presentById_presult__isset {
  _DgiFolderLock_presentById_presult__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_presentById_presult__isset;

class DgiFolderLock_presentById_presult {
 public:


  virtual ~DgiFolderLock_presentById_presult() throw();
   ::dgi::BoolResponse* success;

  _DgiFolderLock_presentById_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DgiFolderLock_remove_args__isset {
  _DgiFolderLock_remove_args__isset() : _sid(false), _flockPath(false) {}
  bool _sid :1;
  bool _flockPath :1;
} _DgiFolderLock_remove_args__isset;

class DgiFolderLock_remove_args {
 public:

  DgiFolderLock_remove_args(const DgiFolderLock_remove_args&);
  DgiFolderLock_remove_args& operator=(const DgiFolderLock_remove_args&);
  DgiFolderLock_remove_args() : _sid(), _flockPath() {
  }

  virtual ~DgiFolderLock_remove_args() throw();
   ::dgi::DgiSid _sid;
   ::dgi::utf8string _flockPath;

  _DgiFolderLock_remove_args__isset __isset;

  void __set__sid(const  ::dgi::DgiSid& val);

  void __set__flockPath(const  ::dgi::utf8string& val);

  bool operator == (const DgiFolderLock_remove_args & rhs) const
  {
    if (!(_sid == rhs._sid))
      return false;
    if (!(_flockPath == rhs._flockPath))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_remove_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_remove_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DgiFolderLock_remove_pargs {
 public:


  virtual ~DgiFolderLock_remove_pargs() throw();
  const  ::dgi::DgiSid* _sid;
  const  ::dgi::utf8string* _flockPath;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_remove_result__isset {
  _DgiFolderLock_remove_result__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_remove_result__isset;

class DgiFolderLock_remove_result {
 public:

  DgiFolderLock_remove_result(const DgiFolderLock_remove_result&);
  DgiFolderLock_remove_result& operator=(const DgiFolderLock_remove_result&);
  DgiFolderLock_remove_result() {
  }

  virtual ~DgiFolderLock_remove_result() throw();
   ::dgi::DgiResult success;

  _DgiFolderLock_remove_result__isset __isset;

  void __set_success(const  ::dgi::DgiResult& val);

  bool operator == (const DgiFolderLock_remove_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_remove_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_remove_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_remove_presult__isset {
  _DgiFolderLock_remove_presult__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_remove_presult__isset;

class DgiFolderLock_remove_presult {
 public:


  virtual ~DgiFolderLock_remove_presult() throw();
   ::dgi::DgiResult* success;

  _DgiFolderLock_remove_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DgiFolderLock_removeAll_args__isset {
  _DgiFolderLock_removeAll_args__isset() : _sid(false) {}
  bool _sid :1;
} _DgiFolderLock_removeAll_args__isset;

class DgiFolderLock_removeAll_args {
 public:

  DgiFolderLock_removeAll_args(const DgiFolderLock_removeAll_args&);
  DgiFolderLock_removeAll_args& operator=(const DgiFolderLock_removeAll_args&);
  DgiFolderLock_removeAll_args() : _sid() {
  }

  virtual ~DgiFolderLock_removeAll_args() throw();
   ::dgi::DgiSid _sid;

  _DgiFolderLock_removeAll_args__isset __isset;

  void __set__sid(const  ::dgi::DgiSid& val);

  bool operator == (const DgiFolderLock_removeAll_args & rhs) const
  {
    if (!(_sid == rhs._sid))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_removeAll_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_removeAll_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DgiFolderLock_removeAll_pargs {
 public:


  virtual ~DgiFolderLock_removeAll_pargs() throw();
  const  ::dgi::DgiSid* _sid;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_removeAll_result__isset {
  _DgiFolderLock_removeAll_result__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_removeAll_result__isset;

class DgiFolderLock_removeAll_result {
 public:

  DgiFolderLock_removeAll_result(const DgiFolderLock_removeAll_result&);
  DgiFolderLock_removeAll_result& operator=(const DgiFolderLock_removeAll_result&);
  DgiFolderLock_removeAll_result() {
  }

  virtual ~DgiFolderLock_removeAll_result() throw();
   ::dgi::DgiResult success;

  _DgiFolderLock_removeAll_result__isset __isset;

  void __set_success(const  ::dgi::DgiResult& val);

  bool operator == (const DgiFolderLock_removeAll_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_removeAll_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_removeAll_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_removeAll_presult__isset {
  _DgiFolderLock_removeAll_presult__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_removeAll_presult__isset;

class DgiFolderLock_removeAll_presult {
 public:


  virtual ~DgiFolderLock_removeAll_presult() throw();
   ::dgi::DgiResult* success;

  _DgiFolderLock_removeAll_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DgiFolderLock_getCacheInfo_args {
 public:

  DgiFolderLock_getCacheInfo_args(const DgiFolderLock_getCacheInfo_args&);
  DgiFolderLock_getCacheInfo_args& operator=(const DgiFolderLock_getCacheInfo_args&);
  DgiFolderLock_getCacheInfo_args() {
  }

  virtual ~DgiFolderLock_getCacheInfo_args() throw();

  bool operator == (const DgiFolderLock_getCacheInfo_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DgiFolderLock_getCacheInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_getCacheInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DgiFolderLock_getCacheInfo_pargs {
 public:


  virtual ~DgiFolderLock_getCacheInfo_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_getCacheInfo_result__isset {
  _DgiFolderLock_getCacheInfo_result__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_getCacheInfo_result__isset;

class DgiFolderLock_getCacheInfo_result {
 public:

  DgiFolderLock_getCacheInfo_result(const DgiFolderLock_getCacheInfo_result&);
  DgiFolderLock_getCacheInfo_result& operator=(const DgiFolderLock_getCacheInfo_result&);
  DgiFolderLock_getCacheInfo_result() {
  }

  virtual ~DgiFolderLock_getCacheInfo_result() throw();
   ::dgi::FLockCacheInfo success;

  _DgiFolderLock_getCacheInfo_result__isset __isset;

  void __set_success(const  ::dgi::FLockCacheInfo& val);

  bool operator == (const DgiFolderLock_getCacheInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DgiFolderLock_getCacheInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DgiFolderLock_getCacheInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DgiFolderLock_getCacheInfo_presult__isset {
  _DgiFolderLock_getCacheInfo_presult__isset() : success(false) {}
  bool success :1;
} _DgiFolderLock_getCacheInfo_presult__isset;

class DgiFolderLock_getCacheInfo_presult {
 public:


  virtual ~DgiFolderLock_getCacheInfo_presult() throw();
   ::dgi::FLockCacheInfo* success;

  _DgiFolderLock_getCacheInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class DgiFolderLockClient : virtual public DgiFolderLockIf {
 public:
  DgiFolderLockClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  DgiFolderLockClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getSubsState( ::dgi::SubSystemStateResponse& _return);
  void send_getSubsState();
  void recv_getSubsState( ::dgi::SubSystemStateResponse& _return);
  void isSupportedFs( ::dgi::BoolResponse& _return, const std::string& _path);
  void send_isSupportedFs(const std::string& _path);
  void recv_isSupportedFs( ::dgi::BoolResponse& _return);
   ::dgi::DgiStatus::type add(const  ::dgi::DgiSid& _sid, const  ::dgi::FLockInfo& _flock);
  void send_add(const  ::dgi::DgiSid& _sid, const  ::dgi::FLockInfo& _flock);
   ::dgi::DgiStatus::type recv_add();
  void getFlocks( ::dgi::FLockListResponse& _return, const  ::dgi::DgiSid& _sid);
  void send_getFlocks(const  ::dgi::DgiSid& _sid);
  void recv_getFlocks( ::dgi::FLockListResponse& _return);
  void getState( ::dgi::FLockStateResponse& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  void send_getState(const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  void recv_getState( ::dgi::FLockStateResponse& _return);
  void setState( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath, const  ::dgi::FLockState::type _newState);
  void send_setState(const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath, const  ::dgi::FLockState::type _newState);
  void recv_setState( ::dgi::DgiResult& _return);
  void present( ::dgi::BoolResponse& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  void send_present(const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  void recv_present( ::dgi::BoolResponse& _return);
  void presentById( ::dgi::BoolResponse& _return, const  ::dgi::DgiSid& _sid, const std::string& _flockId);
  void send_presentById(const  ::dgi::DgiSid& _sid, const std::string& _flockId);
  void recv_presentById( ::dgi::BoolResponse& _return);
  void remove( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  void send_remove(const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  void recv_remove( ::dgi::DgiResult& _return);
  void removeAll( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid);
  void send_removeAll(const  ::dgi::DgiSid& _sid);
  void recv_removeAll( ::dgi::DgiResult& _return);
  void getCacheInfo( ::dgi::FLockCacheInfo& _return);
  void send_getCacheInfo();
  void recv_getCacheInfo( ::dgi::FLockCacheInfo& _return);
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class DgiFolderLockProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::apache::thrift::stdcxx::shared_ptr<DgiFolderLockIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (DgiFolderLockProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_getSubsState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_isSupportedFs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_add(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getFlocks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_present(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_presentById(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_remove(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeAll(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getCacheInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  DgiFolderLockProcessor(::apache::thrift::stdcxx::shared_ptr<DgiFolderLockIf> iface) :
    iface_(iface) {
    processMap_["getSubsState"] = &DgiFolderLockProcessor::process_getSubsState;
    processMap_["isSupportedFs"] = &DgiFolderLockProcessor::process_isSupportedFs;
    processMap_["add"] = &DgiFolderLockProcessor::process_add;
    processMap_["getFlocks"] = &DgiFolderLockProcessor::process_getFlocks;
    processMap_["getState"] = &DgiFolderLockProcessor::process_getState;
    processMap_["setState"] = &DgiFolderLockProcessor::process_setState;
    processMap_["present"] = &DgiFolderLockProcessor::process_present;
    processMap_["presentById"] = &DgiFolderLockProcessor::process_presentById;
    processMap_["remove"] = &DgiFolderLockProcessor::process_remove;
    processMap_["removeAll"] = &DgiFolderLockProcessor::process_removeAll;
    processMap_["getCacheInfo"] = &DgiFolderLockProcessor::process_getCacheInfo;
  }

  virtual ~DgiFolderLockProcessor() {}
};

class DgiFolderLockProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  DgiFolderLockProcessorFactory(const ::apache::thrift::stdcxx::shared_ptr< DgiFolderLockIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::apache::thrift::stdcxx::shared_ptr< DgiFolderLockIfFactory > handlerFactory_;
};

class DgiFolderLockMultiface : virtual public DgiFolderLockIf {
 public:
  DgiFolderLockMultiface(std::vector<apache::thrift::stdcxx::shared_ptr<DgiFolderLockIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~DgiFolderLockMultiface() {}
 protected:
  std::vector<apache::thrift::stdcxx::shared_ptr<DgiFolderLockIf> > ifaces_;
  DgiFolderLockMultiface() {}
  void add(::apache::thrift::stdcxx::shared_ptr<DgiFolderLockIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void getSubsState( ::dgi::SubSystemStateResponse& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getSubsState(_return);
    }
    ifaces_[i]->getSubsState(_return);
    return;
  }

  void isSupportedFs( ::dgi::BoolResponse& _return, const std::string& _path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->isSupportedFs(_return, _path);
    }
    ifaces_[i]->isSupportedFs(_return, _path);
    return;
  }

   ::dgi::DgiStatus::type add(const  ::dgi::DgiSid& _sid, const  ::dgi::FLockInfo& _flock) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->add(_sid, _flock);
    }
    return ifaces_[i]->add(_sid, _flock);
  }

  void getFlocks( ::dgi::FLockListResponse& _return, const  ::dgi::DgiSid& _sid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getFlocks(_return, _sid);
    }
    ifaces_[i]->getFlocks(_return, _sid);
    return;
  }

  void getState( ::dgi::FLockStateResponse& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getState(_return, _sid, _flockPath);
    }
    ifaces_[i]->getState(_return, _sid, _flockPath);
    return;
  }

  void setState( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath, const  ::dgi::FLockState::type _newState) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setState(_return, _sid, _flockPath, _newState);
    }
    ifaces_[i]->setState(_return, _sid, _flockPath, _newState);
    return;
  }

  void present( ::dgi::BoolResponse& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->present(_return, _sid, _flockPath);
    }
    ifaces_[i]->present(_return, _sid, _flockPath);
    return;
  }

  void presentById( ::dgi::BoolResponse& _return, const  ::dgi::DgiSid& _sid, const std::string& _flockId) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->presentById(_return, _sid, _flockId);
    }
    ifaces_[i]->presentById(_return, _sid, _flockId);
    return;
  }

  void remove( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->remove(_return, _sid, _flockPath);
    }
    ifaces_[i]->remove(_return, _sid, _flockPath);
    return;
  }

  void removeAll( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeAll(_return, _sid);
    }
    ifaces_[i]->removeAll(_return, _sid);
    return;
  }

  void getCacheInfo( ::dgi::FLockCacheInfo& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getCacheInfo(_return);
    }
    ifaces_[i]->getCacheInfo(_return);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class DgiFolderLockConcurrentClient : virtual public DgiFolderLockIf {
 public:
  DgiFolderLockConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  DgiFolderLockConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getSubsState( ::dgi::SubSystemStateResponse& _return);
  int32_t send_getSubsState();
  void recv_getSubsState( ::dgi::SubSystemStateResponse& _return, const int32_t seqid);
  void isSupportedFs( ::dgi::BoolResponse& _return, const std::string& _path);
  int32_t send_isSupportedFs(const std::string& _path);
  void recv_isSupportedFs( ::dgi::BoolResponse& _return, const int32_t seqid);
   ::dgi::DgiStatus::type add(const  ::dgi::DgiSid& _sid, const  ::dgi::FLockInfo& _flock);
  int32_t send_add(const  ::dgi::DgiSid& _sid, const  ::dgi::FLockInfo& _flock);
   ::dgi::DgiStatus::type recv_add(const int32_t seqid);
  void getFlocks( ::dgi::FLockListResponse& _return, const  ::dgi::DgiSid& _sid);
  int32_t send_getFlocks(const  ::dgi::DgiSid& _sid);
  void recv_getFlocks( ::dgi::FLockListResponse& _return, const int32_t seqid);
  void getState( ::dgi::FLockStateResponse& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  int32_t send_getState(const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  void recv_getState( ::dgi::FLockStateResponse& _return, const int32_t seqid);
  void setState( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath, const  ::dgi::FLockState::type _newState);
  int32_t send_setState(const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath, const  ::dgi::FLockState::type _newState);
  void recv_setState( ::dgi::DgiResult& _return, const int32_t seqid);
  void present( ::dgi::BoolResponse& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  int32_t send_present(const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  void recv_present( ::dgi::BoolResponse& _return, const int32_t seqid);
  void presentById( ::dgi::BoolResponse& _return, const  ::dgi::DgiSid& _sid, const std::string& _flockId);
  int32_t send_presentById(const  ::dgi::DgiSid& _sid, const std::string& _flockId);
  void recv_presentById( ::dgi::BoolResponse& _return, const int32_t seqid);
  void remove( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  int32_t send_remove(const  ::dgi::DgiSid& _sid, const  ::dgi::utf8string& _flockPath);
  void recv_remove( ::dgi::DgiResult& _return, const int32_t seqid);
  void removeAll( ::dgi::DgiResult& _return, const  ::dgi::DgiSid& _sid);
  int32_t send_removeAll(const  ::dgi::DgiSid& _sid);
  void recv_removeAll( ::dgi::DgiResult& _return, const int32_t seqid);
  void getCacheInfo( ::dgi::FLockCacheInfo& _return);
  int32_t send_getCacheInfo();
  void recv_getCacheInfo( ::dgi::FLockCacheInfo& _return, const int32_t seqid);
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

} // namespace

#endif
